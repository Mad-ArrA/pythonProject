# AUTOTEST-Python

Как правильно заводить тесты

![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/3c4f8543-59c1-4fb6-9973-851201a77465)

<h2>Пирамида тестирования</h2>

<h3>Виды автотестов</h3>

<b>Юнит-тесты</b> пишут на этапе разработки, чтобы проверить отдельные модули кода.

<b>Интеграционные тесты</b> проверяют, как взаимодействуют части системы. Например, нужно убедиться, что в корзине корректно отображаются цены товаров. Тогда нужно проверить, как работают вместе два компонента: корзина и отображение цен.

<b>E2E-тесты </b>(англ. end-to-end, «от начала до конца») проверяют работу приложения в целом. Тесты этого уровня имитируют действия пользователя: например, проверяют, что на сайте можно найти, заказать и оплатить товар. UI-тесты относятся к этому виду автотестов.

Все виды тестов объединяют в пирамиду тестирования.
![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/71cbf794-8c05-4c8b-9262-da3316fdbec7)

Автотесты API:
 * быстрее и стабильнее,
 * позволяют протестировать укромные места,
 * позволяют протестировать отдельные части приложения независимо друг от друга.


![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/7056dc83-a281-4b80-9483-df907dc5c099)

<h2>Операции со списками</h2>
Списки можно менять. Например, ты можешь удалить элемент или добавить новый.

<code>
//добавить элемент "!" в конец списка some_list
some_list.append("!")

print(some_list) # выведет: ['п', 'r', 'a', 'k', 't', 'i', 'k', 'u', 'm', '!'] </code>


Вот как удаляют элемент:

<code>// удалить элемент с индексом 3
// сейчас это буква 'k'
some_list.pop(3)
print(some_list) # выведет: ['п', 'r', 'a', 't', 'i', 'k', 'u', 'm', '!']

// после удаления индексы элементов сдвинулись
print(some_list[3]) # выведет: t </code>

Ещё списки можно сортировать:

//отсортировать элементы списка по возрастанию

<code>some_list.sort()
    print(some_list) # выведет: ['!', 'a', 'i', 'k', 'm', 'r', 't', 'u', 'п'] </code>

<h2>Кортеж</h2>

Кортеж — это неизменяемая последовательность элементов. В Python её называют tuple (с англ. «кортеж»).
Выглядит кортеж так:
<code>
// это кортеж
// элементы кортежа заключают в круглые скобки
some_tuple = ('p', 'y', 't', 'h', 'o', 'n')  </code>

В отличие от элементов списка, элементы кортежа нельзя менять, удалять или сортировать. Добавить новые — тоже не получится.

![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/59de7c58-e182-474e-9caa-e06826135397)

Итоги

Кортежи похожи на списки, но их не стоит путать. Вот самое важное:
 * Элементы кортежа записывают в круглых скобках: ( и ).
 * Кортежи нельзя редактировать. Операции pop(), append() и sort() с ними не работают.
 * К элементам кортежа можно обратиться по индексу.
 * В кортежах хранят информацию, которая не должна меняться на протяжении программы.


<h2>Словари</h2>

Кроме списков и кортежей, в Python есть ещё словари. Их используют и разработчики, и автоматизаторы. Например, в словаре хранят тело ответа HTTP-запроса. JSON тоже состоит из ключей и значений.

<h3>Что такое словарь</h3>

Словарь — это набор парных значений.

Каждый элемент словаря состоит из двух частей: первая — ключ, вторая — значение. Их разделяют двоеточием.

Например, в словаре tasks хранятся рабочие задачи. Здесь ключи — это приоритет задач, а значения — количество задач такого типа. Всего в словаре четыре пары. Их разделяют запятые.

<code>tasks = {"Высокий":1, "Средний":2, "Низкий":3, "Не указан":5}</code>

![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/4eff8e20-94a6-4e35-ac22-75336173bf5b)


<h3>Ключи — простые и уникальные</h3>

✅ Ключами словаря могут быть только неизменяемые типы данных. К ним относятся:
 * числа,
 * строки,
 * логический тип: True и False.

❌ В словаре не может быть двух одинаковых ключей. Ключ — это уникальный адрес, по которому Python ищет значение в программе. Поэтому он не может повторяться.

Если добавишь в словарь два одинаковых ключа, то потеряешь одно из значений. Ключ добавится в словарь, но лишь один раз. Он примет значение, которое ты напишешь последним.

Например, в словаре new_tasks сохранили задачи на день. Их всего четыре: пройти урок в Практикуме, погулять с собакой, вынести мусор и посмотреть сериал. Ключи здесь — это приоритет задач: 1, 2 или 3. У первой и последней задачи ключи совпадают, хотя так делать нельзя.

<h3>Значения — любые</h3>

✅  Значением словаря может быть что угодно: число, строка, список и даже другой словарь.
Например, можно превратить список bag в словарь. Пусть ключами будут карманы рюкзака, а значениями — списки с предметами.

<code>bag = {"основное отделение":["ноутбук", "зарядка", "вода"],  # вот что получилось
        "передний карман":["ключи", "кошелёк"],
        "левый кармашек сбоку":["кусочек шоколадки"]}

print(bag) </code>

✅  Значения могут быть неуникальными. Они могут повторяться. Например, в переменной button сохранён словарь с кнопками. Ключи — это названия кнопок, а значения — их цвет. Кнопки «Вход» и «Регистрация» обе чёрного цвета.


<h3>Зачем нужен словарь</h3>

Списки и кортежи идеально подходят для хранения однотипных данных. Их используют, когда все значения переменной равноценны. Например, как названия кнопок или блюда меню.

<code>// меню кафе в виде списка
menu = ["омлет", "кофе", "тосты", "каша", "рагу", "грибной суп", "чай"] </code>

Но иногда данные нужно хранить не все вместе, а по группам. Например, меню завтраков отдельно, а меню бизнес-ланча — отдельно.
Можно создать несколько списков, но это не всегда удобно. Информация будет лежать в разных переменных: тебе придётся запоминать их названия.

<code>// список с блюдами завтрака
breakfast_menu = ["омлет", "кофе", "тосты", "каша"] </code>

<code>// список с блюдами бизнес-ланча
lunch_menu = ["рагу", "грибной суп", "чай"] </code>

В этом случае используют словарь. Он позволяет распределять значения по ключам, но при этом хранит все данные в одном месте. Так проще их искать и использовать.

<code>// меню кафе в виде словаря со списками
// в словаре два ключа: "завтраки" и "бизнес-ланч"

menu = {"завтраки":["омлет", "кофе", "тосты", "каша"]
         "бизнес-ланч":["рагу", "грибной суп", "чай"]} </code>



<h3>Как обратиться к значению</h3>

Словарь — это неупорядоченный набор. В отличие от элементов списка, у значений словаря нет порядковых номеров.
Чтобы получить значение словаря, нужно указать его ключ. Это ещё называют получить доступ по ключу.
Доступ по ключу похож на доступ по индексу в списках: нужно написать название словаря, а в квадратных скобках — нужный ключ.

Например, так можно получить возраст пользователя из словаря user_213:


<code>// словарь с данными о пользователе Яндекс Такси
user_213 = {"first_name":"Иван",
             "age":26,
             "languages":["English", "Russian"]}
// получили возраст пользователя
print(user_213["age"]) </code>

Итоги

Когда работаешь со словарями, помни:
 * Для ключей подходят только неизменяемые типы данных: числа, строки и логический тип.
 * Значения словаря могут быть разных типов. В том числе производных — например, списками или словарями.
 * Значения могут повторяться, ключи — нет.

Чтобы получить значения словаря, используют доступ по ключу. Он похож на доступ по индексу в списках. Только вместо индекса указывают ключ.


<h3>Как добавить элемент</h3>

Чтобы добавить элемент в словарь, нужно:
 1. Написать название словаря и поставить после него квадратные скобки. Например, dict_name[].
 2. В скобках указать ключ, которого ещё нет в словаре. Например, new_key.
 3. Поставить оператор присваивания и указать значение, которое хочешь добавить. Например, = new_value.

Вместе получится так:

<code>// добавить в словарь dict_name пару new_key=new_value
dict_name[new_key] = new_value</code>

Обрати внимание: ключ должен быть новым. Иначе ты не добавишь новый элемент, а изменишь существующий.

Пример:
<code>// объявили словарь bag
bag = {"основное отделение":["ноутбук", "зарядка", "вода"], 
        "передний карман":["ключи", "кошелёк"],
        "левый кармашек сбоку":["кусочек шоколадки"]}

// добавили в bag новый элемент
// "правый кармашек сбоку" — это ключ, а "сок" — значение
bag["правый кармашек сбоку"] = ["сок"] 

print(bag) </code>


<h3>Как изменить значение элемента</h3>

Изменение значения похоже на добавление элемента. Только указывают не новый ключ, а существующий.

Если хочешь изменить значение:
 * Напиши название словаря и поставь квадратные скобочки.
 * В квадратных скобках укажи ключ, значение которого будешь менять.
 * Поставь оператор присваивания и укажи новое значение.

<code>// изменить в словаре dict_name значение ключа key на new_value
dict_name[key] = new_value</code> 

Например, нужно заменить в словаре bag сок на лимонад. Он лежит в правом кармашке сбоку:

<code>bag = {"основное отделение":["ноутбук", "зарядка", "вода"], 
       "передний карман":["ключи", "кошелёк"],
       "левый кармашек сбоку":["кусочек шоколадки"],
       "правый кармашек сбоку":["сок"]}

bag["правый кармашек сбоку"] = ["лимонад"] 

print(bag)</code>


<h3>Как удалить элемент</h3>

Значения элементов можно менять, а ключи — нет. Если хочешь изменить ключ, тебе нужно удалить элемент и добавить новый — с тем же значением, но другим ключом.

Чтобы удалить элемент из словаря, используют pop(). Здесь всё работает так же, как со списками. Только вместо индекса элемента в скобках указывают ключ.

<code>// удалить из словаря dict_name элемент с ключом key
dict_name.pop(key) </code>

Случилась неприятность: у рюкзака порвался левый кармашек сбоку. Придётся его удалить из словаря:

<code>bag = {"основное отделение":["ноутбук", "зарядка", "вода"], 
        "передний карман":["ключи", "кошелёк"],
        "левый кармашек сбоку":["кусочек шоколадки"],
        "правый кармашек сбоку":["сок"]}
​
bag.pop("левый кармашек сбоку") # удалить элемент с ключом "левый кармашек сбоку"
​
print(bag) </code>

<i><b>Сложение строк с помощью оператора + называют конкатенацией.</b></i>

<h3>Приоритет операторов</h3>

Приоритет операций в программировании такой же, как в математике.
Сначала идёт возведение в степень, затем умножение и все виды деления. Сложение и вычитание выполняются в последнюю очередь.

![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/19d32afe-3a8a-406d-aa14-419bf5dbb566)

Задача:
Приложение онлайн-магазина высчитывает предварительную сумму покупки. Чтобы её найти, нужно сложить стоимость товаров из корзины и прибавить к ней 2.5%. Этот процент — стоимость доставки.

Допиши код, чтобы он рассчитал сумму покупок пользователя. Можешь записать выражение целиком или собрать его по кусочкам. Тогда создай новые переменные и сохрани в них промежуточные действия.

Решение:
<code>// стоимость первого товара
item_1 = 332

// стоимость второго
item_2 = 8912

// стоимость третьего
item_3 = 999

// процент, который магазин берёт за доставку
delivery = 2.5

// сохрани в переменной общую сумму покупки
// Шаг 1: Складываем стоимость всех товаров
total_items_cost = item_1 + item_2 + item_3

// Шаг 2: Рассчитываем стоимость доставки (2.5% от общей стоимости товаров)
delivery_cost = total_items_cost * delivery / 100

// Шаг 3: Суммируем стоимость товаров и доставки
total = total_items_cost + delivery_cost

print(total)</code>

![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/2b0ec3d4-4095-4507-8124-2a3f47af570a)



<h2>Операторы принадлежности</h2>


Можно использовать операторы принадлежности. Они помогают определить, встречается в наборе нужное значение или нет. Оператора всего два: 
 
 * in — проверяет, что значение входит в набор;
 * not in — проверяет, что значение не входит в набор.

Пример:
<code>recipe = ["молоко", "масло", "яйца", "сахар", "мука", "сахар", "ванилин", "орехи", "мёд"]
print("мёд" in recipe)</code>


Оператор in в словаре проверяет только ключи.


<h3>Как объявить функцию</h3>

Чтобы создать свою функцию, её нужно объявить. Для этого используют ключевое слово def (англ. definition, «определение»). Например:

![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/3a34b024-c12e-4537-9463-0d1686c1ab79)

Имя функции придумывает разработчик. Для удобства используют только строчные буквы, а слова отделяют подчёркиваниями. Например, вместо hello можно написать say_hello. 

За объявлением функции следует код, который функция должна выполнить. Этот код называется телом функции. 
Тело функции пишут с новой строки, сделав отступ из четырёх пробелов. Так Python поймёт, где начинается и заканчивается тело функции:

<code>def hello():
    print("Привет!") // это и есть тело функции </code>

![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/bd1bea52-0c58-43f0-ac6e-24d3d910bf11)


<h2>Функции: возврат значений</h2>

<code>calories = {
   "Hamburger": 600,
   "Cheese Burger": 750,
   "Veggie Burger": 400,
   "Vegan Burger": 350,
   "Sweet Potatoes": 230,
   "Salad": 15,
   "Iced Tea": 70,
   "Lemonade": 90,
}

def calories_counter(item_a, item_b, item_c): #объявление новой функции 
    return calories[item_a] + calories[item_b] + calories[item_c] #возврат значений
print(calories_counter("Hamburger", "Cheese Burger", "Iced Tea")) #вызов новой функции </code>

Сначала он объявил новую функцию. В ней три параметра: item_a, item_b, item_c. Эти параметры как шаблон: позднее им нужно присвоить значения — позиции из меню.

Строка return calories[item_a] + calories[item_b] + calories[item_c]

Дальше Серёга написал ключевое слово return, указал новую переменную calories, а в квадратных скобках — параметр. А вместе получился оператор возврата. Он вернул значения из функции, когда Серёга её вызвал. 

Теперь программа сможет подсчитать сумму калорий в любых трёх блюдах. 

Строка print(calories_counter("Hamburger", "Cheese Burger", "Iced Tea"))

Здесь Серёга вывел на экран результаты подсчёта. Вместо параметров подставил аргументы — три позиции из меню: гамбургер, чизбургер и чай. Получилось 1420 калорий.

Вот тот же фрагмент кода, но с ещё одной строкой, которая должна вывести на экран цену на шоколадный торт. 

<code>def get_price_of_cake_with_discount(cake_type):
    price = 700;
    discount = {
        "шоколадный" : 10,
        "морковный" : 20,
        "ягодный": 0
    }
    current_discount = discount[cake_type]/100;
    price_with_discount = price - price*current_discount;
    return price_with_discount;

print("Цена на шоколадный торт", get_price_of_cake_with_discount("шоколадный"))</code>

<h2>Тестирование функций и ключевое слово assert</h2>

Чтобы узнать, правильный ли результат возвращает функция, можно вывести значение на экран и проверить, что ответ верный. 

Но удобнее сделать эту проверку автоматической. Здесь пригодится ключевое слово assert (англ. «утверждать»). Оно работает как логическое выражение: возвращает True или False. Например, если сумма чисел правда 6, вернёт True, а иначе — False.

![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/276b9142-7489-4fc4-b9c0-5235d71dc6d3)

<h3>Ошибка AssertionError</h3>

Если проверка не прошла, программа вернёт сообщение об ошибке — AssertionError. ****

<h2>Библиотека requests</h2>

![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/1196e533-5f2f-40df-9c1d-d03af45a3f42)

 1. configuration.py — файл содержит необходимые для запроса конфигурационные данные: базовый URL сервиса и путь к API-методу для создания пользователя. Использование отдельного файла конфигурации позволяет централизованно управлять этими параметрами и легко их изменять без переписывания основного кода.

 2. data.py — файл, в котором определяется тело запроса и заголовки. Это обеспечивает структурированное и чистое хранение данных, отправляемых в запросе, и позволяет легко их изменять или расширять при необходимости.
 
 3. sender_stand_request.py — основной файл, импортирующий настройки из configuration.py и данные из data.py, а затем использующий их для создания и отправки POST-запроса. Потом ответ сервера анализируется, а результат выводится в консоль. Это разделение логики на разные файлы делает код более читаемым, удобным для отладки и поддержки.


<h2>Тестирование API по чек-листу: первый тест</h2>

<h3>Базовые правила</h3>

Чтобы написать хорошие автотесты, сначала их нужно спроектировать. Есть три базовых правила:

 * Один тест — одна проверка.
 * Данные должны быть независимы.
 * Тесты должны быть независимы.
   
Этот чек-лист соответствует всем трём правилам. Сейчас ты попробуешь автоматизировать первую проверку из него.

![image](https://github.com/Mad-ArrA/AUTOTEST-Python/assets/56492399/e01203e7-4bce-4222-97a7-03f8ca6d5b41)




https://docs.google.com/spreadsheets/d/196OhsRg21EZkyfP-1xO153libUQO7DTn4H-7f0dbxgw/edit#gid=2006427015
